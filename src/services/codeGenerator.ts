import { Agent, WorkflowStep } from '../stores/useAppStore';

interface GeneratedProject {
  files: { [path: string]: string };
  structure: string[];
  dependencies: string[];
  readme: string;
}

interface TemplateConfig {
  framework: string;
  agents: Agent[];
  workflow: WorkflowStep[];
  projectName: string;
}

class CodeGeneratorService {
  generateProject(config: TemplateConfig): GeneratedProject {
    const { framework, agents, workflow, projectName } = config;
    
    const files: { [path: string]: string } = {};
    
    // Generate main application file
    files['main.py'] = this.generateMainFile(framework, agents, workflow, projectName);
    
    // Generate agent files
    agents.forEach(agent => {
      files[`agents/${agent.name.toLowerCase().replace(/\s+/g, '_')}.py`] = 
        this.generateAgentFile(framework, agent);
    });
    
    // Generate workflow configuration
    files['config/workflow.yaml'] = this.generateWorkflowConfig(workflow);
    
    // Generate requirements file
    files['requirements.txt'] = this.generateRequirements(framework);
    
    // Generate Docker configuration
    files['Dockerfile'] = this.generateDockerfile(framework);
    
    // Generate environment template
    files['.env.template'] = this.generateEnvTemplate(framework);
    
    // Generate README
    const readme = this.generateReadme(config);
    files['README.md'] = readme;
    
    const structure = Object.keys(files).sort();
    const dependencies = this.getFrameworkDependencies(framework);
    
    return { files, structure, dependencies, readme };
  }

  private generateMainFile(framework: string, agents: Agent[], workflow: WorkflowStep[], projectName: string): string {
    switch (framework) {
      case 'crewai':
        return this.generateCrewAIMain(agents, workflow, projectName);
      case 'autogen':
        return this.generateAutoGenMain(agents, workflow, projectName);
      case 'google-adk':
        return this.generateGoogleADKMain(agents, workflow, projectName);
      default:
        return this.generateGenericMain(agents, workflow, projectName);
    }
  }

  private generateCrewAIMain(agents: Agent[], workflow: WorkflowStep[], projectName: string): string {
    return `#!/usr/bin/env python3
"""
${projectName} - CrewAI Multi-Agent System
Generated by Multiagent Development Platform
"""

import os
import logging
from crewai import Crew, Agent, Task, Process
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ${projectName.replace(/\s+/g, '')}Crew:
    def __init__(self):
        self.agents = self._create_agents()
        self.tasks = self._create_tasks()
        self.crew = self._create_crew()
    
    def _create_agents(self):
        """Create and configure all agents"""
        agents = {}
        
        ${agents.map(agent => `
        # ${agent.name} Agent
        agents['${agent.name.toLowerCase()}'] = Agent(
            role='${agent.role}',
            goal='${agent.description}',
            backstory='''${agent.description}''',
            capabilities=${JSON.stringify(agent.capabilities)},
            verbose=True,
            allow_delegation=False
        )`).join('\n        ')}
        
        return agents
    
    def _create_tasks(self):
        """Create tasks based on workflow configuration"""
        tasks = []
        
        ${workflow.map((step, index) => `
        # Task ${index + 1}: ${step.name}
        task_${index + 1} = Task(
            description='${step.name}',
            agent=self.agents.get('${step.agentId || 'default'}'),
            expected_output='Completion of ${step.name}'
        )
        tasks.append(task_${index + 1})`).join('\n        ')}
        
        return tasks
    
    def _create_crew(self):
        """Create the crew with agents and tasks"""
        return Crew(
            agents=list(self.agents.values()),
            tasks=self.tasks,
            process=Process.sequential,
            verbose=2
        )
    
    def run(self):
        """Execute the crew workflow"""
        logger.info("Starting ${projectName} crew execution...")
        
        try:
            result = self.crew.kickoff()
            logger.info("Crew execution completed successfully")
            return result
        except Exception as e:
            logger.error(f"Crew execution failed: {str(e)}")
            raise

def main():
    """Main execution function"""
    crew_system = ${projectName.replace(/\s+/g, '')}Crew()
    result = crew_system.run()
    
    print("\\n" + "="*50)
    print("CREW EXECUTION RESULT")
    print("="*50)
    print(result)
    print("="*50)

if __name__ == "__main__":
    main()
`;
  }

  private generateAutoGenMain(agents: Agent[], workflow: WorkflowStep[], projectName: string): string {
    return `#!/usr/bin/env python3
"""
${projectName} - AutoGen Multi-Agent System
Generated by Multiagent Development Platform
"""

import os
import logging
import autogen
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Configuration for LLM
config_list = [
    {
        "model": "gpt-4",
        "api_key": os.getenv("OPENAI_API_KEY"),
    }
]

llm_config = {
    "config_list": config_list,
    "temperature": 0.7,
}

class ${projectName.replace(/\s+/g, '')}System:
    def __init__(self):
        self.agents = self._create_agents()
        self.group_chat = self._create_group_chat()
        self.manager = self._create_manager()
    
    def _create_agents(self):
        """Create and configure all agents"""
        agents = {}
        
        ${agents.map(agent => `
        # ${agent.name} Agent
        agents['${agent.name.toLowerCase()}'] = autogen.AssistantAgent(
            name="${agent.name}",
            system_message='''You are a ${agent.role}. ${agent.description}
            Your capabilities include: ${agent.capabilities.join(', ')}.
            Always provide detailed and actionable responses.''',
            llm_config=llm_config
        )`).join('\n        ')}
        
        # User Proxy Agent
        agents['user_proxy'] = autogen.UserProxyAgent(
            name="UserProxy",
            system_message="A human admin who coordinates the multi-agent workflow.",
            code_execution_config={"last_n_messages": 3, "work_dir": "workspace"},
            human_input_mode="NEVER"
        )
        
        return agents
    
    def _create_group_chat(self):
        """Create group chat with all agents"""
        return autogen.GroupChat(
            agents=list(self.agents.values()),
            messages=[],
            max_round=10
        )
    
    def _create_manager(self):
        """Create group chat manager"""
        return autogen.GroupChatManager(
            groupchat=self.group_chat,
            llm_config=llm_config
        )
    
    def run(self, initial_message: str):
        """Execute the multi-agent conversation"""
        logger.info("Starting ${projectName} system execution...")
        
        try:
            self.agents['user_proxy'].initiate_chat(
                self.manager,
                message=initial_message
            )
            logger.info("System execution completed successfully")
        except Exception as e:
            logger.error(f"System execution failed: {str(e)}")
            raise

def main():
    """Main execution function"""
    system = ${projectName.replace(/\s+/g, '')}System()
    
    initial_message = '''
    Welcome to ${projectName}! 
    
    Workflow Steps:
    ${workflow.map((step, index) => `${index + 1}. ${step.name}`).join('\n    ')}
    
    Please coordinate to complete these tasks efficiently.
    '''
    
    system.run(initial_message)

if __name__ == "__main__":
    main()
`;
  }

  private generateGoogleADKMain(agents: Agent[], workflow: WorkflowStep[], projectName: string): string {
    return `#!/usr/bin/env python3
"""
${projectName} - Google ADK Multi-Agent System
Generated by Multiagent Development Platform
"""

import os
import logging
from google_adk import Agent, Workflow, Task
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ${projectName.replace(/\s+/g, '')}Workflow:
    def __init__(self):
        self.agents = self._create_agents()
        self.workflow = self._create_workflow()
    
    def _create_agents(self):
        """Create and configure all agents"""
        agents = {}
        
        ${agents.map(agent => `
        # ${agent.name} Agent
        agents['${agent.name.toLowerCase()}'] = Agent(
            name="${agent.name}",
            role="${agent.role}",
            description="${agent.description}",
            capabilities=${JSON.stringify(agent.capabilities)},
            config={
                "temperature": 0.7,
                "max_tokens": 1000
            }
        )`).join('\n        ')}
        
        return agents
    
    def _create_workflow(self):
        """Create workflow with tasks"""
        workflow = Workflow(name="${projectName}")
        
        ${workflow.map((step, index) => `
        # Task ${index + 1}: ${step.name}
        task_${index + 1} = Task(
            name="${step.name}",
            agent=self.agents['${step.agentId || 'default'}'],
            dependencies=${JSON.stringify(step.dependencies)},
            config=${JSON.stringify(step.config)}
        )
        workflow.add_task(task_${index + 1})`).join('\n        ')}
        
        return workflow
    
    def run(self):
        """Execute the workflow"""
        logger.info("Starting ${projectName} workflow execution...")
        
        try:
            result = self.workflow.execute()
            logger.info("Workflow execution completed successfully")
            return result
        except Exception as e:
            logger.error(f"Workflow execution failed: {str(e)}")
            raise

def main():
    """Main execution function"""
    workflow_system = ${projectName.replace(/\s+/g, '')}Workflow()
    result = workflow_system.run()
    
    print("\\n" + "="*50)
    print("WORKFLOW EXECUTION RESULT")
    print("="*50)
    print(result)
    print("="*50)

if __name__ == "__main__":
    main()
`;
  }

  private generateGenericMain(agents: Agent[], workflow: WorkflowStep[], projectName: string): string {
    return `#!/usr/bin/env python3
"""
${projectName} - Generic Multi-Agent System
Generated by Multiagent Development Platform
"""

import os
import logging
import asyncio
from typing import Dict, List, Any
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class Agent:
    def __init__(self, name: str, role: str, description: str, capabilities: List[str]):
        self.name = name
        self.role = role
        self.description = description
        self.capabilities = capabilities
    
    async def execute_task(self, task: str, context: Dict[str, Any] = None) -> str:
        """Execute a task based on agent capabilities"""
        logger.info(f"{self.name} executing task: {task}")
        
        # Simulate task execution
        await asyncio.sleep(1)
        
        result = f"Task '{task}' completed by {self.name} ({self.role})"
        return result

class ${projectName.replace(/\s+/g, '')}System:
    def __init__(self):
        self.agents = self._create_agents()
        self.workflow = self._create_workflow()
    
    def _create_agents(self):
        """Create and configure all agents"""
        agents = {}
        
        ${agents.map(agent => `
        agents['${agent.name.toLowerCase()}'] = Agent(
            name="${agent.name}",
            role="${agent.role}",
            description="${agent.description}",
            capabilities=${JSON.stringify(agent.capabilities)}
        )`).join('\n        ')}
        
        return agents
    
    def _create_workflow(self):
        """Create workflow steps"""
        return ${JSON.stringify(workflow, null, 8)}
    
    async def execute_workflow(self):
        """Execute the complete workflow"""
        logger.info("Starting ${projectName} workflow execution...")
        
        results = []
        context = {}
        
        for step in self.workflow:
            agent = self.agents.get(step.get('agentId', ''))
            if not agent:
                logger.warning(f"Agent not found for step: {step['name']}")
                continue
            
            try:
                result = await agent.execute_task(step['name'], context)
                results.append({
                    'step': step['name'],
                    'agent': agent.name,
                    'result': result
                })
                
                # Update context for next steps
                context[step['name']] = result
                
            except Exception as e:
                logger.error(f"Step execution failed: {str(e)}")
                results.append({
                    'step': step['name'],
                    'agent': agent.name,
                    'error': str(e)
                })
        
        return results

async def main():
    """Main execution function"""
    system = ${projectName.replace(/\s+/g, '')}System()
    results = await system.execute_workflow()
    
    print("\\n" + "="*50)
    print("WORKFLOW EXECUTION RESULTS")
    print("="*50)
    
    for result in results:
        print(f"Step: {result['step']}")
        print(f"Agent: {result['agent']}")
        if 'error' in result:
            print(f"Error: {result['error']}")
        else:
            print(f"Result: {result['result']}")
        print("-" * 30)

if __name__ == "__main__":
    asyncio.run(main())
`;
  }

  private generateAgentFile(framework: string, agent: Agent): string {
    return `"""
${agent.name} Agent Implementation
Role: ${agent.role}
Description: ${agent.description}
"""

import logging
from typing import Dict, Any, List

logger = logging.getLogger(__name__)

class ${agent.name.replace(/\s+/g, '')}Agent:
    def __init__(self):
        self.name = "${agent.name}"
        self.role = "${agent.role}"
        self.description = "${agent.description}"
        self.capabilities = ${JSON.stringify(agent.capabilities)}
    
    def process_task(self, task: str, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Process a task using agent capabilities"""
        logger.info(f"${agent.name} processing task: {task}")
        
        result = {
            "agent": self.name,
            "task": task,
            "status": "completed",
            "output": f"Task processed by {self.name}",
            "capabilities_used": self.capabilities
        }
        
        return result
    
    def get_agent_info(self) -> Dict[str, Any]:
        """Get agent information"""
        return {
            "name": self.name,
            "role": self.role,
            "description": self.description,
            "capabilities": self.capabilities
        }
`;
  }

  private generateWorkflowConfig(workflow: WorkflowStep[]): string {
    const yamlConfig = {
      workflow: {
        name: "Generated Workflow",
        version: "1.0",
        steps: workflow.map(step => ({
          id: step.id,
          name: step.name,
          type: step.type,
          agent_id: step.agentId,
          dependencies: step.dependencies,
          config: step.config
        }))
      }
    };
    
    return `# Workflow Configuration
# Generated by Multiagent Development Platform

${this.objectToYaml(yamlConfig)}
`;
  }

  private generateRequirements(framework: string): string {
    const baseDeps = [
      'python-dotenv>=1.0.0',
      'pyyaml>=6.0',
      'requests>=2.28.0',
      'aiohttp>=3.8.0',
    ];
    
    const frameworkDeps = {
      'crewai': ['crewai>=0.1.0', 'langchain>=0.1.0'],
      'autogen': ['pyautogen>=0.2.0', 'openai>=1.0.0'],
      'google-adk': ['google-adk>=1.0.0', 'google-cloud>=0.34.0'],
    };
    
    const deps = [...baseDeps, ...(frameworkDeps[framework as keyof typeof frameworkDeps] || [])];
    
    return deps.join('\n') + '\n';
  }

  private generateDockerfile(framework: string): string {
    return `# Dockerfile for ${framework} Multi-Agent System
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \\
    build-essential \\
    curl \\
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create workspace directory
RUN mkdir -p workspace

# Set environment variables
ENV PYTHONPATH=/app
ENV PYTHONUNBUFFERED=1

# Expose port for web interface (if applicable)
EXPOSE 8000

# Command to run the application
CMD ["python", "main.py"]
`;
  }

  private generateEnvTemplate(framework: string): string {
    const baseEnvVars = [
      '# API Keys and Configuration',
      '# Copy this file to .env and fill in your actual values',
      '',
      '# OpenAI API Key (required for most frameworks)',
      'OPENAI_API_KEY=your_openai_api_key_here',
      '',
      '# Logging Level',
      'LOG_LEVEL=INFO',
    ];
    
    const frameworkEnvVars = {
      'crewai': [
        '',
        '# CrewAI Configuration',
        'CREWAI_API_KEY=your_crewai_api_key_here',
        'SERPER_API_KEY=your_serper_api_key_here',
      ],
      'autogen': [
        '',
        '# AutoGen Configuration',
        'AUTOGEN_MODEL=gpt-4',
        'AUTOGEN_TEMPERATURE=0.7',
      ],
      'google-adk': [
        '',
        '# Google ADK Configuration',
        'GOOGLE_APPLICATION_CREDENTIALS=path/to/service-account.json',
        'GOOGLE_PROJECT_ID=your_project_id',
      ],
    };
    
    const envVars = [...baseEnvVars, ...(frameworkEnvVars[framework as keyof typeof frameworkEnvVars] || [])];
    
    return envVars.join('\n') + '\n';
  }

  private generateReadme(config: TemplateConfig): string {
    const { framework, agents, workflow, projectName } = config;
    
    return `# ${projectName}

A multi-agent system built with ${framework.toUpperCase()} framework.

*Generated by Multiagent Development Platform*

## Overview

This project implements a multi-agent system with ${agents.length} specialized agents working together to accomplish complex tasks through an automated workflow.

## Agents

${agents.map(agent => `
### ${agent.name}
- **Role**: ${agent.role}
- **Description**: ${agent.description}
- **Capabilities**: ${agent.capabilities.join(', ')}
`).join('')}

## Workflow

The system follows a ${workflow.length}-step workflow:

${workflow.map((step, index) => `${index + 1}. **${step.name}** (${step.type})`).join('\n')}

## Installation

1. Clone this repository
2. Install dependencies:
   \`\`\`bash
   pip install -r requirements.txt
   \`\`\`

3. Configure environment variables:
   \`\`\`bash
   cp .env.template .env
   # Edit .env with your API keys
   \`\`\`

## Usage

### Running the System

\`\`\`bash
python main.py
\`\`\`

### Docker Deployment

\`\`\`bash
# Build the image
docker build -t ${projectName.toLowerCase().replace(/\s+/g, '-')} .

# Run the container
docker run -d --env-file .env ${projectName.toLowerCase().replace(/\s+/g, '-')}
\`\`\`

## Configuration

The system can be configured through:

- **Environment Variables**: Set in \`.env\` file
- **Workflow Configuration**: Modify \`config/workflow.yaml\`
- **Agent Parameters**: Update individual agent files in \`agents/\` directory

## Architecture

\`\`\`
${projectName}
├── main.py              # Main execution script
├── agents/              # Individual agent implementations
├── config/              # Configuration files
├── workspace/           # Working directory for agents
├── requirements.txt     # Python dependencies
├── Dockerfile          # Container configuration
└── .env.template       # Environment variables template
\`\`\`

## Framework: ${framework.toUpperCase()}

${this.getFrameworkDescription(framework)}

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Test thoroughly
5. Submit a pull request

## License

This project is generated code and follows standard open-source practices.

## Support

For issues related to the generated code, please refer to the ${framework} documentation.
For platform-specific issues, contact the Multiagent Development Platform support team.

---

*Generated on ${new Date().toISOString()} by Multiagent Development Platform*
`;
  }

  private getFrameworkDescription(framework: string): string {
    const descriptions = {
      'crewai': 'CrewAI is a cutting-edge framework for orchestrating role-playing, autonomous AI agents. By fostering collaborative intelligence, CrewAI empowers agents to work together seamlessly, tackling complex tasks as a unified team.',
      'autogen': 'AutoGen is a framework that enables the development of LLM applications using multiple agents that can converse with each other to solve tasks. AutoGen agents are customizable, conversable, and seamlessly allow human participation.',
      'google-adk': 'Google Agent Development Kit (ADK) provides tools and frameworks for building intelligent agent systems that can interact with various Google services and APIs.',
    };
    
    return descriptions[framework as keyof typeof descriptions] || 'A powerful framework for building multi-agent systems.';
  }

  private getFrameworkDependencies(framework: string): string[] {
    const deps = {
      'crewai': ['crewai', 'langchain', 'openai'],
      'autogen': ['pyautogen', 'openai'],
      'google-adk': ['google-adk', 'google-cloud'],
    };
    
    return deps[framework as keyof typeof deps] || [];
  }

  private objectToYaml(obj: any, indent = 0): string {
    const spaces = ' '.repeat(indent);
    let yaml = '';
    
    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        yaml += `${spaces}${key}:\n${this.objectToYaml(value, indent + 2)}`;
      } else if (Array.isArray(value)) {
        yaml += `${spaces}${key}:\n`;
        value.forEach(item => {
          if (typeof item === 'object') {
            yaml += `${spaces}  -\n${this.objectToYaml(item, indent + 4)}`;
          } else {
            yaml += `${spaces}  - ${item}\n`;
          }
        });
      } else {
        yaml += `${spaces}${key}: ${value}\n`;
      }
    }
    
    return yaml;
  }
}

export const codeGenerator = new CodeGeneratorService();