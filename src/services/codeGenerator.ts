import { Agent, WorkflowStep } from '../stores/useAppStore';

interface GeneratedProject {
  files: { [path: string]: string };
  structure: string[];
  dependencies: string[];
  readme: string;
}

interface TemplateConfig {
  framework: string;
  agents: Agent[];
  workflow: WorkflowStep[];
  projectName: string;
}

class CodeGeneratorService {
  generateProject(config: TemplateConfig): GeneratedProject {
    const { framework, agents, workflow, projectName } = config;
    
    const files: { [path: string]: string } = {};
    
    // Generate main application file
    files['main.py'] = this.generateMainFile(framework, agents, workflow, projectName);
    
    // Generate agent files
    agents.forEach(agent => {
      files[`agents/${agent.name.toLowerCase().replace(/\s+/g, '_')}.py`] = 
        this.generateAgentFile(framework, agent);
    });
    
    // Generate workflow configuration
    files['config/workflow.yaml'] = this.generateWorkflowConfig(workflow);
    
    // Generate requirements file
    files['requirements.txt'] = this.generateRequirements(framework);
    
    // Generate Docker configuration
    files['Dockerfile'] = this.generateDockerfile(framework);
    
    // Generate environment template
    files['.env.template'] = this.generateEnvTemplate(framework);
    
    // Generate README
    const readme = this.generateReadme(config);
    files['README.md'] = readme;
    
    const structure = Object.keys(files).sort();
    const dependencies = this.getFrameworkDependencies(framework);
    
    return { files, structure, dependencies, readme };
  }

  private generateMainFile(framework: string, agents: Agent[], workflow: WorkflowStep[], projectName: string): string {
    switch (framework) {
      case 'crewai':
        return this.generateCrewAIMain(agents, workflow, projectName);
      case 'autogen':
        return this.generateAutoGenMain(agents, workflow, projectName);
      case 'google-adk':
        return this.generateGoogleADKMain(agents, workflow, projectName);
      default:
        return this.generateGenericMain(agents, workflow, projectName);
    }
  }

  private generateCrewAIMain(agents: Agent[], workflow: WorkflowStep[], projectName: string): string {
    return `#!/usr/bin/env python3
"""
${projectName} - CrewAI Multi-Agent System
Generated by Multiagent Development Platform
"""

import os
import logging
from crewai import Crew, Agent, Task, Process
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ${projectName.replace(/\s+/g, '')}Crew:
    def __init__(self):
        self.agents = self._create_agents()
        self.tasks = self._create_tasks()
        self.crew = self._create_crew()
    
    def _create_agents(self):
        """Create and configure all agents"""
        agents = {}
        
        ${agents.map(agent => `
        # ${agent.name} Agent
        agents['${agent.name.toLowerCase()}'] = Agent(
            role='${agent.role}',
            goal='${agent.description}',
            backstory='''${agent.description}''',
            capabilities=${JSON.stringify(agent.capabilities)},
            verbose=True,
            allow_delegation=False
        )`).join('\n        ')}
        
        return agents
    
    def _create_tasks(self):
        """Create tasks based on workflow configuration"""
        tasks = []
        
        ${workflow.map((step, index) => `
        # Task ${index + 1}: ${step.name}
        task_${index + 1} = Task(
            description='${step.name}',
            agent=self.agents.get('${step.agentId || 'default'}'),
            expected_output='Completion of ${step.name}'
        )
        tasks.append(task_${index + 1})`).join('\n        ')}
        
        return tasks
    
    def _create_crew(self):
        """Create the crew with agents and tasks"""
        return Crew(
            agents=list(self.agents.values()),
            tasks=self.tasks,
            process=Process.sequential,
            verbose=2
        )
    
    def run(self):
        """Execute the crew workflow"""
        logger.info("Starting ${projectName} crew execution...")
        
        try:
            result = self.crew.kickoff()
            logger.info("Crew execution completed successfully")
            return result
        except Exception as e:
            logger.error(f"Crew execution failed: {str(e)}")
            raise

def main():
    """Main execution function"""
    crew_system = ${projectName.replace(/\s+/g, '')}Crew()
    result = crew_system.run()
    
    print("\\n" + "="*50)
    print("CREW EXECUTION RESULT")
    print("="*50)
    print(result)
    print("="*50)

if __name__ == "__main__":
    main()
`;
  }

  private generateAutoGenMain(agents: Agent[], workflow: WorkflowStep[], projectName: string): string {
    return `#!/usr/bin/env python3
"""
${projectName} - AutoGen Multi-Agent System
Generated by Multiagent Development Platform
"""

import os
import logging
import autogen
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Configuration for LLM using Gemini
config_list = [
    {
        "model": "gemini-pro",
        "api_key": os.getenv("GEMINI_API_KEY"),
        "api_type": "gemini",
        "api_base": "https://generativelanguage.googleapis.com/v1beta",
    }
]

llm_config = {
    "config_list": config_list,
    "temperature": 0.7,
}

class ${projectName.replace(/\s+/g, '')}System:
    def __init__(self):
        self.agents = self._create_agents()
        self.group_chat = self._create_group_chat()
        self.manager = self._create_manager()
    
    def _create_agents(self):
        """Create and configure all agents"""
        agents = {}
        
        ${agents.map(agent => `
        # ${agent.name} Agent
        agents['${agent.name.toLowerCase()}'] = autogen.AssistantAgent(
            name="${agent.name}",
            system_message='''You are a ${agent.role}. ${agent.description}
            Your capabilities include: ${agent.capabilities.join(', ')}.
            Always provide detailed and actionable responses.''',
            llm_config=llm_config
        )`).join('\n        ')}
        
        # User Proxy Agent
        agents['user_proxy'] = autogen.UserProxyAgent(
            name="UserProxy",
            system_message="A human admin who coordinates the multi-agent workflow.",
            code_execution_config={"last_n_messages": 3, "work_dir": "workspace"},
            human_input_mode="NEVER"
        )
        
        return agents
    
    def _create_group_chat(self):
        """Create group chat with all agents"""
        return autogen.GroupChat(
            agents=list(self.agents.values()),
            messages=[],
            max_round=10
        )
    
    def _create_manager(self):
        """Create group chat manager"""
        return autogen.GroupChatManager(
            groupchat=self.group_chat,
            llm_config=llm_config
        )
    
    def run(self, initial_message: str):
        """Execute the multi-agent conversation"""
        logger.info("Starting ${projectName} system execution...")
        
        try:
            self.agents['user_proxy'].initiate_chat(
                self.manager,
                message=initial_message
            )
            logger.info("System execution completed successfully")
        except Exception as e:
            logger.error(f"System execution failed: {str(e)}")
            raise

def main():
    """Main execution function"""
    system = ${projectName.replace(/\s+/g, '')}System()
    
    initial_message = '''
    Welcome to ${projectName}! 
    
    Workflow Steps:
    ${workflow.map((step, index) => `${index + 1}. ${step.name}`).join('\n    ')}
    
    Please coordinate to complete these tasks efficiently.
    '''
    
    system.run(initial_message)

if __name__ == "__main__":
    main()
`;
  }

  private generateGoogleADKMain(agents: Agent[], workflow: WorkflowStep[], projectName: string): string {
    return `#!/usr/bin/env python3
"""
${projectName} - Google ADK Multi-Agent System
Generated by Multiagent Development Platform
"""

import os
import logging
from google_adk import Agent, Workflow, Task
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ${projectName.replace(/\s+/g, '')}Workflow:
    def __init__(self):
        self.agents = self._create_agents()
        self.workflow = self._create_workflow()
    
    def _create_agents(self):
        """Create and configure all agents"""
        agents = {}
        
        ${agents.map(agent => `
        # ${agent.name} Agent
        agents['${agent.name.toLowerCase()}'] = Agent(
            name="${agent.name}",
            role="${agent.role}",
            description="${agent.description}",
            capabilities=${JSON.stringify(agent.capabilities)},
            config={
                "model": "gemini-pro",
                "api_key": os.getenv("GEMINI_API_KEY"),
                "temperature": 0.7,
                "max_tokens": 1000
            }
        )`).join('\n        ')}
        
        return agents
    
    def _create_workflow(self):
        """Create workflow with tasks"""
        workflow = Workflow(name="${projectName}")
        
        ${workflow.map((step, index) => `
        # Task ${index + 1}: ${step.name}
        task_${index + 1} = Task(
            name="${step.name}",
            agent=self.agents['${step.agentId || 'default'}'],
            dependencies=${JSON.stringify(step.dependencies)},
            config=${JSON.stringify(step.config)}
        )
        workflow.add_task(task_${index + 1})`).join('\n        ')}
        
        return workflow
    
    def run(self):
        """Execute the workflow"""
        logger.info("Starting ${projectName} workflow execution...")
        
        try:
            result = self.workflow.execute()
            logger.info("Workflow execution completed successfully")
            return result
        except Exception as e:
            logger.error(f"Workflow execution failed: {str(e)}")
            raise

def main():
    """Main execution function"""
    workflow_system = ${projectName.replace(/\s+/g, '')}Workflow()
    result = workflow_system.run()
    
    print("\\n" + "="*50)
    print("WORKFLOW EXECUTION RESULT")
    print("="*50)
    print(result)
    print("="*50)

if __name__ == "__main__":
    main()
`;
  }

  private generateGenericMain(agents: Agent[], workflow: WorkflowStep[], projectName: string): string {
    return `#!/usr/bin/env python3
"""
${projectName} - Generic Multi-Agent System
Generated by Multiagent Development Platform
"""

import os
import logging
import asyncio
import google.generativeai as genai
from typing import Dict, List, Any
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Configure Gemini API
genai.configure(api_key=os.getenv("GEMINI_API_KEY"))

class Agent:
    def __init__(self, name: str, role: str, description: str, capabilities: List[str]):
        self.name = name
        self.role = role
        self.description = description
        self.capabilities = capabilities
        self.model = genai.GenerativeModel('gemini-pro')
    
    async def execute_task(self, task: str, context: Dict[str, Any] = None) -> str:
        """Execute a task based on agent capabilities"""
        logger.info(f"{self.name} executing task: {task}")
        
        prompt = f"""
        You are {self.name}, a {self.role}.
        Description: {self.description}
        Capabilities: {', '.join(self.capabilities)}
        
        Task: {task}
        Context: {context or {}}
        
        Please complete this task using your capabilities and provide a detailed response.
        """
        
        try:
            response = await self.model.generate_content_async(prompt)
            result = response.text
            logger.info(f"{self.name} completed task: {task}")
            return result
        except Exception as e:
            logger.error(f"{self.name} failed to complete task: {str(e)}")
            return f"Task '{task}' failed: {str(e)}"

class ${projectName.replace(/\s+/g, '')}System:
    def __init__(self):
        self.agents = self._create_agents()
        self.workflow = self._create_workflow()
    
    def _create_agents(self):
        """Create and configure all agents"""
        agents = {}
        
        ${agents.map(agent => `
        agents['${agent.name.toLowerCase()}'] = Agent(
            name="${agent.name}",
            role="${agent.role}",
            description="${agent.description}",
            capabilities=${JSON.stringify(agent.capabilities)}
        )`).join('\n        ')}
        
        return agents
    
    def _create_workflow(self):
        """Create workflow steps"""
        return ${JSON.stringify(workflow, null, 8)}
    
    async def execute_workflow(self):
        """Execute the complete workflow"""
        logger.info("Starting ${projectName} workflow execution...")
        
        results = []
        context = {}
        
        for step in self.workflow:
            agent = self.agents.get(step.get('agentId', ''))
            if not agent:
                logger.warning(f"Agent not found for step: {step['name']}")
                continue
            
            try:
                result = await agent.execute_task(step['name'], context)
                results.append({
                    'step': step['name'],
                    'agent': agent.name,
                    'result': result
                })
                
                # Update context for next steps
                context[step['name']] = result
                
            except Exception as e:
                logger.error(f"Step execution failed: {str(e)}")
                results.append({
                    'step': step['name'],
                    'agent': agent.name,
                    'error': str(e)
                })
        
        return results

async def main():
    """Main execution function"""
    system = ${projectName.replace(/\s+/g, '')}System()
    results = await system.execute_workflow()
    
    print("\\n" + "="*50)
    print("WORKFLOW EXECUTION RESULTS")
    print("="*50)
    
    for result in results:
        print(f"Step: {result['step']}")
        print(f"Agent: {result['agent']}")
        if 'error' in result:
            print(f"Error: {result['error']}")
        else:
            print(f"Result: {result['result']}")
        print("-" * 30)

if __name__ == "__main__":
    asyncio.run(main())
`;
  }

  private generateAgentFile(framework: string, agent: Agent): string {
    return `"""
${agent.name} Agent Implementation
Role: ${agent.role}
Description: ${agent.description}
"""

import logging
import os
import google.generativeai as genai
from typing import Dict, Any, List

logger = logging.getLogger(__name__)

# Configure Gemini API
genai.configure(api_key=os.getenv("GEMINI_API_KEY"))

class ${agent.name.replace(/\s+/g, '')}Agent:
    def __init__(self):
        self.name = "${agent.name}"
        self.role = "${agent.role}"
        self.description = "${agent.description}"
        self.capabilities = ${JSON.stringify(agent.capabilities)}
        self.model = genai.GenerativeModel('gemini-pro')
    
    async def process_task(self, task: str, context: Dict[str, Any] = None) -> Dict[str, Any]:
        """Process a task using agent capabilities"""
        logger.info(f"${agent.name} processing task: {task}")
        
        prompt = f"""
        You are {self.name}, a {self.role}.
        Description: {self.description}
        Capabilities: {', '.join(self.capabilities)}
        
        Task: {task}
        Context: {context or {}}
        
        Please process this task and provide a structured response.
        """
        
        try:
            response = await self.model.generate_content_async(prompt)
            
            result = {
                "agent": self.name,
                "task": task,
                "status": "completed",
                "output": response.text,
                "capabilities_used": self.capabilities
            }
            
            return result
        except Exception as e:
            logger.error(f"Task processing failed: {str(e)}")
            return {
                "agent": self.name,
                "task": task,
                "status": "failed",
                "error": str(e),
                "capabilities_used": []
            }
    
    def get_agent_info(self) -> Dict[str, Any]:
        """Get agent information"""
        return {
            "name": self.name,
            "role": self.role,
            "description": self.description,
            "capabilities": self.capabilities
        }
`;
  }

  private generateWorkflowConfig(workflow: WorkflowStep[]): string {
    const yamlConfig = {
      workflow: {
        name: "Generated Workflow",
        version: "1.0",
        steps: workflow.map(step => ({
          id: step.id,
          name: step.name,
          type: step.type,
          agent_id: step.agentId,
          dependencies: step.dependencies,
          config: step.config
        }))
      }
    };
    
    return `# Workflow Configuration
# Generated by Multiagent Development Platform

${this.objectToYaml(yamlConfig)}
`;
  }

  private generateRequirements(framework: string): string {
    const baseDeps = [
      'python-dotenv>=1.0.0',
      'pyyaml>=6.0',
      'requests>=2.28.0',
      'aiohttp>=3.8.0',
      'google-generativeai>=0.3.0',
    ];
    
    const frameworkDeps = {
      'crewai': ['crewai>=0.1.0', 'langchain>=0.1.0'],
      'autogen': ['pyautogen>=0.2.0'],
      'google-adk': ['google-adk>=1.0.0', 'google-cloud>=0.34.0'],
    };
    
    const deps = [...baseDeps, ...(frameworkDeps[framework as keyof typeof frameworkDeps] || [])];
    
    return deps.join('\n') + '\n';
  }

  private generateDockerfile(framework: string): string {
    return `# Dockerfile for ${framework} Multi-Agent System
FROM python:3.11-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \\
    build-essential \\
    curl \\
    && rm -rf /var/lib/apt/lists/*

# Copy requirements and install Python dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application code
COPY . .

# Create workspace directory
RUN mkdir -p workspace

# Set environment variables
ENV PYTHONPATH=/app
ENV PYTHONUNBUFFERED=1

# Expose port for web interface (if applicable)
EXPOSE 8000

# Command to run the application
CMD ["python", "main.py"]
`;
  }

  private generateEnvTemplate(framework: string): string {
    const baseEnvVars = [
      '# API Keys and Configuration',
      '# Copy this file to .env and fill in your actual values',
      '',
      '# Gemini API Key (required for AI functionality)',
      'GEMINI_API_KEY=your_gemini_api_key_here',
      '',
      '# Logging Level',
      'LOG_LEVEL=INFO',
    ];
    
    const frameworkEnvVars = {
      'crewai': [
        '',
        '# CrewAI Configuration',
        'CREWAI_API_KEY=your_crewai_api_key_here',
        'SERPER_API_KEY=your_serper_api_key_here',
      ],
      'autogen': [
        '',
        '# AutoGen Configuration',
        'AUTOGEN_MODEL=gemini-pro',
        'AUTOGEN_TEMPERATURE=0.7',
      ],
      'google-adk': [
        '',
        '# Google ADK Configuration',
        'GOOGLE_APPLICATION_CREDENTIALS=path/to/service-account.json',
        'GOOGLE_PROJECT_ID=your_project_id',
      ],
    };
    
    const envVars = [...baseEnvVars, ...(frameworkEnvVars[framework as keyof typeof frameworkEnvVars] || [])];
    
    return envVars.join('\n') + '\n';
  }

  private generateReadme(config: TemplateConfig): string {
    const { framework, agents, workflow, projectName } = config;
    
    return `# ${projectName}

A multi-agent system built with ${framework.toUpperCase()} framework and powered by Google Gemini AI.

*Generated by Multiagent Development Platform*

## Overview

This project implements a multi-agent system with ${agents.length} specialized agents working together to accomplish complex tasks through an automated workflow. The system uses Google's Gemini AI for natural language processing and reasoning.

## Agents

${agents.map(agent => `
### ${agent.name}
- **Role**: ${agent.role}
- **Description**: ${agent.description}
- **Capabilities**: ${agent.capabilities.join(', ')}
`).join('')}

## Workflow

The system follows a ${workflow.length}-step workflow:

${workflow.map((step, index) => `${index + 1}. **${step.name}** (${step.type})`).join('\n')}

## Installation

1. Clone this repository
2. Install dependencies:
   \`\`\`bash
   pip install -r requirements.txt
   \`\`\`

3. Configure environment variables:
   \`\`\`bash
   cp .env.template .env
   # Edit .env with your Gemini API key
   \`\`\`

4. Get your Gemini API key:
   - Visit [Google AI Studio](https://makersuite.google.com/app/apikey)
   - Create a new API key
   - Add it to your .env file as GEMINI_API_KEY

## Usage

### Running the System

\`\`\`bash
python main.py
\`\`\`

### Docker Deployment

\`\`\`bash
# Build the image
docker build -t ${projectName.toLowerCase().replace(/\s+/g, '-')} .

# Run the container
docker run -d --env-file .env ${projectName.toLowerCase().replace(/\s+/g, '-')}
\`\`\`

## Configuration

The system can be configured through:

- **Environment Variables**: Set in \`.env\` file
- **Workflow Configuration**: Modify \`config/workflow.yaml\`
- **Agent Parameters**: Update individual agent files in \`agents/\` directory

## Architecture

\`\`\`
${projectName}
├── main.py              # Main execution script
├── agents/              # Individual agent implementations
├── config/              # Configuration files
├── workspace/           # Working directory for agents
├── requirements.txt     # Python dependencies
├── Dockerfile          # Container configuration
└── .env.template       # Environment variables template
\`\`\`

## Framework: ${framework.toUpperCase()}

${this.getFrameworkDescription(framework)}

## AI Model: Google Gemini

This system uses Google's Gemini AI model for:
- Natural language understanding
- Task reasoning and planning
- Content generation
- Multi-turn conversations

### Gemini Features Used:
- **Gemini Pro**: Advanced reasoning and text generation
- **Async Processing**: Non-blocking AI operations
- **Context Awareness**: Maintains conversation context
- **Safety Filters**: Built-in content safety

## API Usage and Costs

Google Gemini offers generous free tier limits:
- **Free Tier**: 60 requests per minute
- **Rate Limits**: 1,500 requests per day
- **Token Limits**: Up to 30,000 tokens per minute

For production use, consider upgrading to paid tiers for higher limits.

## Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Test thoroughly
5. Submit a pull request

## License

This project is generated code and follows standard open-source practices.

## Support

For issues related to the generated code, please refer to the ${framework} documentation.
For Gemini API issues, visit [Google AI documentation](https://ai.google.dev/).
For platform-specific issues, contact the Multiagent Development Platform support team.

---

*Generated on ${new Date().toISOString()} by Multiagent Development Platform*
*Powered by Google Gemini AI*
`;
  }

  private getFrameworkDescription(framework: string): string {
    const descriptions = {
      'crewai': 'CrewAI is a cutting-edge framework for orchestrating role-playing, autonomous AI agents. By fostering collaborative intelligence, CrewAI empowers agents to work together seamlessly, tackling complex tasks as a unified team.',
      'autogen': 'AutoGen is a framework that enables the development of LLM applications using multiple agents that can converse with each other to solve tasks. AutoGen agents are customizable, conversable, and seamlessly allow human participation.',
      'google-adk': 'Google Agent Development Kit (ADK) provides tools and frameworks for building intelligent agent systems that can interact with various Google services and APIs.',
    };
    
    return descriptions[framework as keyof typeof descriptions] || 'A powerful framework for building multi-agent systems.';
  }

  private getFrameworkDependencies(framework: string): string[] {
    const deps = {
      'crewai': ['crewai', 'langchain', 'google-generativeai'],
      'autogen': ['pyautogen', 'google-generativeai'],
      'google-adk': ['google-adk', 'google-cloud', 'google-generativeai'],
    };
    
    return deps[framework as keyof typeof deps] || ['google-generativeai'];
  }

  private objectToYaml(obj: any, indent = 0): string {
    const spaces = ' '.repeat(indent);
    let yaml = '';
    
    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        yaml += `${spaces}${key}:\n${this.objectToYaml(value, indent + 2)}`;
      } else if (Array.isArray(value)) {
        yaml += `${spaces}${key}:\n`;
        value.forEach(item => {
          if (typeof item === 'object') {
            yaml += `${spaces}  -\n${this.objectToYaml(item, indent + 4)}`;
          } else {
            yaml += `${spaces}  - ${item}\n`;
          }
        });
      } else {
        yaml += `${spaces}${key}: ${value}\n`;
      }
    }
    
    return yaml;
  }
}

export const codeGenerator = new CodeGeneratorService();